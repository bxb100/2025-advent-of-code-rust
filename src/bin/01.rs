use adv_code_2025::*;
use anyhow::*;
use code_timing_macros::time_snippet;
use const_format::{concatcp, str_get};
use itertools::Itertools;
use std::fs::{read, File};
use std::io::{BufRead, BufReader, Cursor};
use std::ops::{Div, Rem};

const DAY: &str = "01";
const INPUT_FILE: &str = concatcp!("input/", DAY, ".txt");

const TEST: &str = r#"
L68
L30
R48
L5
R60
L55
L1
L99
R14
L82
"#;

fn main() -> Result<()> {
    start_day(DAY);

    //region Part 1
    // println!("=== Part 1 ===");
    //
    // fn part1<R: BufRead>(reader: R) -> Result<usize> {
    //     let start = 50;
    //     let mut point = start;
    //     let mut pass = 0;
    //
    //     for line in reader.lines() {
    //         let line = line?;
    //         let line = line.trim();
    //         if line.is_empty() {
    //             continue;
    //         }
    //         let (a, b) = line.split_at(1);
    //         let n: i32 = b.parse()?;
    //         point = match a {
    //             "L" => point - n,
    //             "R" => point + n,
    //             _ => panic!("Invalid rotation"),
    //         } % 100;
    //         if point == 0 {
    //             pass += 1;
    //         } else if point < 0 {
    //             point += 100;
    //         }
    //     }
    //
    //     Ok(pass)
    // }
    //
    // assert_eq!(3, part1(BufReader::new(TEST.as_bytes()))?);
    //
    // let input_file = BufReader::new(File::open(INPUT_FILE)?);
    // let result = time_snippet!(part1(input_file)?);
    // println!("Result = {}", result);
    //endregion

    //region Part 2
    println!("\n=== Part 2 ===");

    fn part2<R: BufRead>(reader: R) -> Result<usize> {
        let start = 50;
        let mut point = start;
        let mut pass = 0;

        for line in reader.lines() {
            let line = line?;
            let line = line.trim();
            if line.is_empty() {
                continue;
            }
            let (a, b) = line.split_at(1);
            let n = b.parse::<i32>()?;
            let mut is_left = false;
            let pre = point;
            point = match a {
                "L" => {
                    is_left = true;
                    point - n
                }
                "R" => point + n,
                _ => return Err(anyhow!("Invalid rotation")),
            };
            // core: edge case, left rotation and not start from 0
            if is_left && point <= 0 && pre != 0 {
                pass += 1;
            }

            // this is only calc the 1 circle pass
            let t = point.div(100).unsigned_abs();
            pass += t as usize;

            point = point.rem_euclid(100);

            // println!("{point} {pass}");
        }
        Ok(pass)
    }

    assert_eq!(6, part2(BufReader::new(TEST.as_bytes()))?);

    let input_file = BufReader::new(File::open(INPUT_FILE)?);
    let result = time_snippet!(part2(input_file)?);
    // 5657
    println!("Result = {}", result);
    //endregion

    Ok(())
}

#[cfg(test)]
mod tests {
    use std::ops::Div;

    #[test]
    fn test_zero() {
        let a = (-130i32).div(100).unsigned_abs();
        let b = 0.div(100);
        println!("{a} {b}")
    }

    // This brute-force generated by gemini to check the right answer
    #[allow(dead_code)]
    fn solve_safe_dial(start_pos: i32, instructions: Vec<&str>) -> usize {
        let mut current_pos = start_pos;
        let mut zero_hits = 0;

        for instruction in instructions {
            if instruction.is_empty() {
                continue;
            }

            let direction = &instruction[0..1]; // 'L' or 'R'
            let amount: i32 = instruction[1..].parse().expect("Invalid number");

            // click
            for _ in 0..amount {
                match direction {
                    "R" => {
                        current_pos += 1;
                        if current_pos == 100 {
                            current_pos = 0;
                        }
                    }
                    "L" => {
                        current_pos -= 1;
                        if current_pos < 0 {
                            current_pos = 99;
                        }
                    }
                    _ => panic!("Unknown direction: {}", direction),
                }

                if current_pos == 0 {
                    zero_hits += 1;
                }
            }
        }

        println!("Final Position: {}, Zero Hits: {}", current_pos, zero_hits);

        zero_hits
    }
}
